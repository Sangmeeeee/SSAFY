문제 : [보행자 천국](https://programmers.co.kr/learn/courses/30/lessons/1832)

알고리즘 종류 : 다이나믹 프로그래밍

참조 url : 

# 1. 알고리즘 설명

경로의 총 개수는 정수형을 넘을 수 있다는 조건이기 때문에 bfs로 하면 시간초과가 날것이라 생각했다.

그렇다면 다이나믹 프로그래밍일거라 생각했지만 dp의 조건을 두기 어려워 참조 url을 참조했다.

dp[dir][y][x]를 두어 dir이 0일경우 해당 y, x좌표에서 아래로 향하는 도로일때의 개수,

dir이 1일 경우 해당 y, x좌표에서 오른쪽으로 향하는 도로일때의 개수를 둔다.

그리고 cityMap을 가로 2칸, 세로 2칸 확대해서 아래와같이 

![image](https://user-images.githubusercontent.com/24482602/173560020-78a4c7b9-1e08-4c7e-8af8-3e81994ad7fe.png)

새로운 cityMap을 만들어주고 빨간색부위에 원래 cityMap을 복사해준다.

기본적으로 특정 (y, x)좌표로 들어올 수 있는 좌표는 (y - 1, x), (y, x - 1)좌표에서 들어올 수 있다.

자동차는 오른쪽 아니면 아래로 이동할 수 있기 때문이다.

문제는 (y, x)좌표의 map이 2일때이다. 

(y, x)좌표가 2일때

dp[0][y][x]는 아래로 향하게 된다. 따라서 dp[0][y - 1][x]좌표의 값을 그대로 들고온다.

dp[1][y][x]는 오른쪽으로 향하게 된다. 따라서 dp[1][y][x - 1]좌표의 값을 그대로 들고온다.

(y, x)좌표가 0이라면 dp[0][y][x]던 dp[1][y][x]던 값이 같다.

따라서 dp[0][y][x] = dp[0][y - 1][x](위에서 들어온 경로) + dp[1][y][x - 1](오른쪽에서 들어온 경로)

dp[1][y][x] = dp[0][y - 1][x](위에서 들어온 경로) + dp[1][y][x - 1](오른쪽에서 들어온 경로)

이 된다.

따라서 dp[dir][y][x]의 값을 구하기 위해선 dp[0][y - 1][x], dp[1][y][x - 1]의 값이 필요하다.

그 후 dp[0][m][n]의 값을 구하면 정답이 된다.

이때, dp[0][m - 1][n] + dp[1][m][n - 1]의 값을 해주면 안된다.

해당 좌표의 map 값이 2일수도 있기 때문이다.

# 2. 새로 배운 내용
