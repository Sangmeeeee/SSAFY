문제 : [리틀 프렌즈 사천성](https://programmers.co.kr/learn/courses/30/lessons/1836)

알고리즘 종류 : 

참조 url : 

# 1. 알고리즘 설명

특정 타일에서 짝 지어진 타일로 가기 위해선 한번만 꺾거나 아예 일직선의 길이 있어야한다.

또한 해당 길에는 벽이나 다른 타일이 존재해서는 안된다.

여러개의 답이 나올수도 있지만 문제의 조건상 알파벳 순으로 정렬해줘야한다.

내가 생각한 과정은

1. 알파벳의 오름차순, 알파벳이 같다면 y값의 오름차순으로 정렬해준다.
2. 정렬한 노드들을 하나씩 돌며 같은 알파벳을 가진 노드들끼리 (x평행이동 -> y평행이동) 혹은 (y평행이동 -> x평행이동)을 했을때 중간에 벽이 없거나 평행이동이 가능할 때 제거해주고 제거한 알파벳 기준 전 알파벳을 판단해준다.
3. 이를 노드 처음부터 끝까지 반복해주며 만들어진 문자열의 길이가 알파벳의 개수일 경우 만들어진 문자열을 그대로 리턴해주고 만약 아니라면 IMPOSSIBLE을 리턴해준다.

1번 과정을 수행하기 위해 Node라는 클래스를 만들고 알파벳의 오름차순, y값의 오름차순으로 우선순위를 정해준다.

2번 과정을 수행하기 위해 list의 idx를 2씩 이동시키며(카드는 2개니까) x평행이동 -> y평행이동, y평행이동 -> x평행이동시 걸리는게 없고 제거가 가능하면 해당 엘리먼트를 리스트에서 제거해주고

idx를 2줄여준다. idx를 2씩 줄이는 이유는 ABCD...이런 순서로 카드가 존재할 때 D를 제거했다면 C를 제거해줘야한다.

만약 C가 제거된다면 또 다시 B를 제거해주고 만약 C가 제거되지 않는다면 D다음의 알파벳이 계속해서 제거 가능하다면 언젠가는 C가 제거 가능할지 불가능할지 판단할 수 있게 된다.

    .AC
    .*C
    .*A

위와 같은 상황이 있을 수 있기 때문이다.

만약 A라는 알파벳이 있을 때, 평행이동의 판단은 아래와 같이 해주었다.

![image](https://user-images.githubusercontent.com/24482602/172195853-f3771cc6-d753-4723-b5a5-92564bd23090.png)

# 2. 새로 배운 내용
