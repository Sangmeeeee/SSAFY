# Info

문제 : [이차원 배열과 연산](https://www.acmicpc.net/problem/17140)

알고리즘 종류 : 구현, 시뮬레이션, 정렬

참조 url : 없음

# 알고리즘 설명
우선 배열의 행과 열의 길이에 따라 R 연산 or C 연산이 실행된다.</br>
1. 쓸데없는 연산을 방지하기 위해 R 연산과 C 연산을 실행하기 전에 a[r-1][c-1]==k의 조건이 성립하면 바로 빠져 나올 수 있도록 해준다.</br>
2. 1번의 조건이 성립하지 않으면 본격적으로 배열 탐색이 시작된다.</br>
3. while 문으로 우선 초는 100초가 초과하지 않도록 조건을 둔다.</br>
4. 새로운 배열 a를 생성하여 R 연산 or C 연산의 결과를 저장해둘 수 있도록 한다. 여기서 중요한건 배열 값이 0이면 count 해주지 않기!</br>
5. a[r-1][c-1]==k 조건이 통과하면 값을 출력하고 그렇지 않으면 계속 조건이 성립할 수 있도록 반복해서 연산해준다. 만약 100초가 넘는다면 -1 출력!

<R 연산></br>
collections의 Counter를 이용하여 배열 값마다 얼마나 쓰였는지 계산해준다.
그리고 그 값을 뽑아내서 배열 a에 저장시켜준다. 
마지막으로는 행마다 가장 긴 열의 값을 구해서 그 열의 값에 비해 부족한 길이 만큼 0을 append 해준다. 

<C 연산></br>
C 연산은 R 연산보다 조금 더 복잡하다. C 연산을 시작하기 전에 행을 열로 열을 행으로 바꾼 배열을 map과 zip을 사용하여 R 연산과 똑같이 진행해준다. 연산을 마친 뒤 또 다시 행과 열을 서로 바꾸는 작업을 해주고 저장해준다.


# 새로 배운 내용
시뮬레이션 문제는 보통 문제 길이가 길어서 정말 꼼꼼하게 읽어야한다.. 문제 길이가 길더라도 침착하게 읽으며 예외 처리까지 확인해주고 문제를 풀자..!