# Info

문제 : [이차원 배열과 연산](https://www.acmicpc.net/problem/17140)

알고리즘 종류 : 구현

참조 url : https://wlshddlek.tistory.com/44

C연산이 까다로워서 봤다가 입력값을 배열로 받는 것과 정렬 이후에 값 채워넣는 부분을 참고했다.

# 1. 알고리즘 설명

2차원 배열(A)에 입력 받고 최대 행 길이(max_r_size), 최대 열 길이(max_c_size)로 범위를 제한하며 배열 값을 수정했다.

또한 pair 데이터를 담는 벡터(cnt)를 선언하여 연산 시 배열에 저장된 수와 그 수의 등장 횟수를 저장한다. 

R 연산과 C 연산은 인덱스 참조만 다를뿐 둘 다 다음과 같은 로직으로 진행된다.

1. 전체 행/열을 탐색하며 각 인덱스에 해당하는 숫자와 등장횟수를 pair 형태로 cnt 벡터에 저장한다.
2. 커스텀 함수(compare)를 선언하여 cnt 벡터에 저장된 데이터들을 등장횟수 순으로 정렬한 후 크기 순으로 정렬한다.
3. cnt 벡터의 0인 데이터들로 인해 실제 데이터가 제일 뒷쪽으로 가기 때문에 새로운 벡터(temp)를 선언하여 실제 데이터들을 원래 순서대로 저장한다.
4. 이때 temp의 길이, 즉 새로 업데이트 할 데이터들의 길이가 해당 연산 내의 행/열 최대 길이보다 길다면 이를 temp의 길이로 업데이트 해준다.
5. 배열 A의 값을 갱신하는데 temp의 길이만큼은 temp에 저장된 데이터들을, 그 후 최대 행/열 길이만큼은 0을 대입한다.
6. 연산이 끝난 후 전체 최대 행/열 길이를 해당 연산 내의 최대 행/열 길이로 갱신한다.

# 2. 새로 배운 내용

**2개의 기준으로 정렬해야 할 때 custom compare 함수 작성하는 법**

이번 문제의 경우 등장 횟수가 1순위, 크기가 2순위로 정렬되어야 한다.

pair에 저장된 데이터 중에서 first는 배열에 저장된 수이고 second는 등장 횟수로, `i.second`와 `j.second`가 같은 경우 `i.first < j.first`에 대한 boolean 값을 return 하면 문제에서 원하는대로 정렬이 된다.

```cpp
bool compare(pair<int, int> i, pair<int, int> j) {
	if (i.second == j.second)
		return i.first < j.first;
	return i.second < j.second;
}
```

만약 내림차순으로 정렬하고 싶다면 비교 연산자의 방향을 바꾸면 된다.
