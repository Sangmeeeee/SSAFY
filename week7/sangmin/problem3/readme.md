문제 : [박스 채우기](https://www.acmicpc.net/problem/1493)

알고리즘 종류 : 분할정복

참조 url : https://excited-hyun.tistory.com/114, https://steady-coding.tistory.com/14

# 1. 알고리즘 설명

2개의 Solution으로 해결해보았는데 공통적인 전략은 한변의 길이가 4인 큐브 8개보다 한변의 길이가 8인 큐브 하나를 쓰는게 큐브의 개수를 가장 적게 사용하는 방법이다.

1번 Solution은 재귀를 이용해서 분할정복 + 구현방식으로 해결했다.

가장 큰 박스를 넣을 수 있다면 넣고 넣은 박스를 기준으로 가로, 세로, 높이를 새로운 직육면체로 보고 해당 직육면체에 넣을 수 있는 가장 큰 박스를 넣어주는 방식이다.

![image](https://user-images.githubusercontent.com/24482602/157439668-cf151807-6bb2-439a-85b0-386f8fae2997.png)

위의 그림으로 설명하자면 노랑, 주황, 초록에 대해 계속해서 분할하면서 넣을 수 있는 최대 크기의 큐브를 구해주는것이다.

2번 Solution은 분할정복으로 해결하였는데

넣을 수 있는 가장 큰 박스를 넣어주고 2^i번째 박스는 2^i-1번째 박스를 8개 쓰는것과 같기 때문에 이를 역으로 치환하여 해결해주었다.

먼저 1번 Soluition은 넣을 수 있는 가장 큰 크기의 큐브를 넣고 나머지 부분을 3개의 새로운 직육면체로 나눠준다.

새로운 직육면체에 대해서도 계속해서 가장 큰 크기의 큐브를 넣고 나머지 부분을 3개의 새로운 직육면체로 나누어주는데,

만약 나눈 직육면체의 면 중 하나라도 0 이하가 나온다면 재귀를 종료해준다.

그리고 나누었지만 넣을 수 있는 가장 큰 크기의 큐브가 존재하지 않는다는 뜻은 해당 칸을 채울 수 없다는 뜻이기 때문에 정답을 -1로 출력해준다.

2번 Solution은 공간을 가장 큰 수의 큐브로 가득 채우는 갯수를 구해주고 해당 갯수와 실제 가지고 있는 큐브의 갯수를 비교해준다.

둘 중 더 작은값을 선택해서 해당 공간을 채워주고 그 다음 크기의 큐브로 넘어간다. 이 때 가장 큰 큐브는 몇개 들어가 있을지에 대한 값이 있을것이다.

그 값은 일단 무시하고 전체 공간을 봤을때 그 다음 크기의 큐브로 몇개나 들어갈 수 있는지 구해준다. 만약 n의 개수가 나왔다면 실질적으로 들어가는 큐브의 개수는

n - 가장 큰 큐브가 들어가있는 개수 * 8이다. 그렇다면 공간을 가장 큰 큐브 + 2번째로 큰 큐브로 채웠을때의 개수는

가장 큰 큐브가 들어가있는 개수 + (n - 가장 큰 큐브가 들어가있는 개수 * 8)이 된다.

이를 계속해서 반복하다보면

가장 큰 큐브 ~ 크기가 가장 작은 큐브를 넣을 수 있는만큼 넣었을때의 부피를 구할 수 있게 된다. 해당 부피가 전체 공간의 부피와 같다면 정답을 출력해준다.

# 2. 새로 배운 내용