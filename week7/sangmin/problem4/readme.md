문제 : [Moo 게임](https://www.acmicpc.net/problem/5904)

알고리즘 종류 : 분할정복

참조 url : 

# 1. 알고리즘 설명

S(k)를 k번째 Moo 배열의 크기라고 생각할 때, 일단 N을 입력했을때 어느 S(k)에 속해있는지 찾아준다.

S(k + 1)번째 Moo 배열의 크기가 N보다 클 경우 N은 S(k)에 속해있다.

만약 k를 찾았다면 이번에는 역으로 0까지 돌아가면서 N이 어디에 속해있는지 판단한다.

돌아갈때 S(k)를 나누면서 생각해준다.

S(k) = S(k - 1) + (k + 3) + S(k - 1)로 생각할 수 있는데

왼쪽 S(k-1)을 left, (k + 3)을 mid, 오른쪽 S(k - 1)을 right로 생각한다.

이제 재귀를 돌아가면서 k의 크기를 한칸씩 줄여준다.

1. left는 1, mid는 mid가 시작하는 idx, right_start는 right가 시작하는 idx로 둔다.
2. S(k)에서 mid는 left(1) + S(k - 1)이 된다.
3. S(k)에서 right_start는 mid + k + 3이 된다.
4. S(k)에서 S(k - 1)는 (S(k) - (k + 3)) / 2가 된다.
5. 만약 N이 left에 속해있다면 N은 S(k-1)에 속해있기 때문에 k - 1로 재귀 탐색한다.
6. 만약 N이 mid에 속해있다면 N - mid를 해줘서 0인경우만 "m"을 출력해주고 재귀를 종료한다.
7. 만약 N이 right에 속해있다면 N - right_start를 해주어 N번째 글자가 right에서 몇번째 글자에 속해있는지 알아온다. right에 속해있다는건 S(k - 1)에 속해있다는것과 같다는 말이기 떄문에 N - right_start를 앞에서 해주었고, right를 left처럼 취급할 수 있다. (right를 right_start만큼 당겼기 때문)
9. 재귀 탐색의 종료 조건은 현재 S(k)가 3이 되었을때(S(0)이 되었을때) 종료해주는데, 종료할 경우 N은 현재 S(k)에서 몇번째 글자인지 나타내고 있다. 따라서 N이 1일경우 "m"을 출력해준다.

# 2. 새로 배운 내용