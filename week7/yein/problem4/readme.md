# Info

문제 : [Moo 게임](https://www.acmicpc.net/problem/5904)

알고리즘 종류 : 분할 정복

참조 url : 없음

# 알고리즘 설명

- N이 10의 9제곱까지가 최대이기때문에 수열을 하나하나 구해준다면 메모리 초과가 난다.
- 이를 위해서 분할 정복으로 풀이했다.

![image](https://user-images.githubusercontent.com/77979505/157690195-d9cda37a-dfc0-4f10-9d51-b1dd89d5b9c4.png)

- 우선 Moo수열은 규칙성을 띄는 수열이다. 그래서 수열을 3개정도 구해보며 문자열의 길이에 대한 점화식을 구해봤다. 그에 맞는 문자열의 길이에 대한 점화식은 위에 사진에 있는 것과 같다. 그래서 점화식을 기반으로 N번째 글자가 존재하는 수열이 몇번째인지 구해줬다.
- k번째 수열은 k-1번째 수열을 앞 뒤로 붙이고 중간에 문자는 m + o\*( k+2) 인 규칙성을 띈다. 그래서 하나하나 문자열을 구하지 않고 문자열 길이를 이용하여 N번째의 글자를 구해주도록 했다.
- 예시로 S[2]로 보여줬는데 저렇게 3등분하여 구간을 나눠줬다.
- 만약 N이 앞쪽 문자열의 길이보다 작거나 같으면 return moo(prevLen,middleLen-1,N)을 해준다.
- 그게 아닌 N이 뒷쪽 문자열쪽에 있다면 return moo(prevLen,middleLen-1,N-prevLen-middleLen)을 해준다.
- 앞쪽과 뒷쪽이 아닌 중간이라면 중간의 문자열은 m + o\*(k+2) 이므로 맨 앞 글자는 항상 m이고 맨 앞쪽이 아닌 다른 곳은 항상 o 이기 때문에 그 원리를 이용하여 N번째의 글자를 구해줬다.

# 새로 배운 내용
