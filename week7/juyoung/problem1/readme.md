# Info

문제 : [소형기관차](https://www.acmicpc.net/problem/2616)

알고리즘 종류 : 누적합, DP

참조 url : 


# 1. 알고리즘 설명

우선 **누적합**은 각 소형기관차가 주어진 개수만큼 객차를 끌 때 운송할 수 있는 승객의 수를 구하는 데에 사용했다.

그리고 이를 이용해 1번 소형기관차부터 3번 소형기관차까지 차례대로 DP 배열을 채워줬다.

최대로 끌 수 있는 객차의 수가 `K`일때, dp 배열의 정의는 다음과 같다.

- `dp[i][j]` = i번 소형기관차가 (j-K+1)번부터 j번 객차까지 끌 때 운송할 수 있는 최대 승객의 수

소형기관차가 3개이므로 dp 배열은 0번 행을 제외한 총 3개의 행으로 이루어진다.

각 행을 채우는 점화식은 다음과 같다.

- `dp[1][j] = dp[1][j] = max(dp[1][j - 1], people[j] - people[j - K])`
- `dp[2][j] = max(dp[2][j - 1], people[j] - people[j - K] + dp[1][j - K])`
- `dp[3][j] = max(dp[3][j - 1], people[j] - people[j - K] + dp[2][j - K])`

dp 배열의 1행, 즉 1번 소형 기관차는 이전 객차까지 봤을 때 최대로 태울 수 있는 승객의 수와 현재 객차까지 포함해서 K개를 끌 때 태울 수 있는 승객의 수를 비교하여 더 큰 수를 저장해주기만 하면 된다.

하지만 2행부터는 현재 끌려는 객차 K개의 승객의 수 + 이때 1번 소형기관차가 최대로 태울 수 있는 승객의 수와 `dp[2][j-1]`을 비교해야 한다.

`dp[2][j-1]`에는 이전 객차까지 봤을 때, 소형기관차 2가 최대로 태울 수 있는 승객의 수가 저장되어 있다.

![KakaoTalk_20220307_225408919](https://user-images.githubusercontent.com/57346428/157049155-d5d34135-24fb-4474-8627-e73f150e6dcd.jpg)


코드 작성 시 주의해야 할 점은, 1번 소형기관차는 최소 1~K번 객차를 끌 수 있으므로 dp 배열을 채울 때 K열부터 채워야 한다는 점이다.

2번 소형기관차도 1번 소형기관차가 제일 앞 K개의 객차를 끌 때 최소 K+1~K*2번 객차부터 끌 수 있으므로 K*2열부터 채워야 한다.

3번 소형기관차도 마찬가지이다.


# 2. 새로 배운 내용(코드 위주)
