# Info

문제 : [플로이드](https://www.acmicpc.net/problem/11404)

알고리즘 종류 : 플로이드 와샬

참조 url : 


# 1. 알고리즘 설명

첫째, 주어진 입력을 통해 그래프에 대한 **인접 행렬을 만든다.**  
문제에서 한 출발 정점에서 도착 정점까지의 노선이 2개 이상일 수 있다고 했으므로  
이미 인접 행렬의 해당 인덱스에 값이 존재하면, 그 값과 입력된 값 중 더 작은 값을 대입한다.  
또한 출발 정점과 도착 정점이 같지 않은데 값이 0이면 해당 노선은 존재하지 않는다는 의미이므로
이후 플로이드 와샬 알고리즘 수행을 위해 해당 원소에 충분히 큰 값을 대입해주었다.

둘째, **플로이드 와샬 알고리즘을 수행**한다.  
거쳐가는 정점을 기준으로 행렬을 반복적으로 갱신한다.  
거쳐가는 정점이 `N`이라고 했을 때,
**`i`에서 `j`까지의 비용 vs `i`에서 `N`까지의 비용 + `N`에서 `j`까지의 비용**  
둘 중 더 작은 값으로 행렬을 갱신한다.

셋째, 출력한다.  
이때 아까 첫번째 과정에서 충분히 큰 값으로 바꿔주었던 부분이  
아직도 그 값 그대로라면, 출력할 때는 0으로 바꾸어 줄력해준다.  
(이것 때문에 틀렸다 ㅠㅠ)


# 2. 새로 배운 내용(코드 위주)
### 플로이드 와샬(Floyd Warshall) 알고리즘
다익스트라 알고리즘이 하나의 정점에서 다른 모든 정점으로의 최단 경로를 구하는 알고리즘이었다면,  
플로이드 와샬은 *모든 정점에서 모든 정점으로의 최단 경로*를 구하는 알고리즘이다.

다이나믹 프로그래밍 방식으로 행렬의 각 원소를 업데이트하며,  
3중 for문으로 간단히 구현할 수 있다.  
```cpp
for(int k=0; k<N; k++) // 거쳐가는 정점
	for(int i=0; i<N; i++) // 행 (출발 정점)
		for(int j=0; j<N; j++) // 열 (도착 정점)
			if(a[i][k] + a[k][j] < a[i][j])
				a[i][j] = a[i][k] + a[k][j];
```