문제 : [한 번 남았다](https://www.acmicpc.net/problem/13317)

알고리즘 종류 : 벨만포드

참조 url :

# 1. 알고리즘 설명

일단 이 문제는 기본적으로 c++을 어느정도 읽을 줄 알아야한다.

다행히 예전에 코테를 c++로 준비해서 어느정도 읽을 수 있었다.

단지 내가 문제를 똑바로 읽지 않았을 뿐...

    일단 이 문제는 입력값을 입력해주면 올바른 벨만포드 알고리즘과 올바르지 않은 벨만포드 알고리즘이 두개 돌아가고

    return 값으로 음의 싸이클이 존재하는지 아닌지 판단하는 boolean 값이 return되고

    올바른 벨만포드 알고리즘은 싸이클이 없다고 return(true) 해주고 올바르지 않은 벨만포드 알고리즘은 싸이클이 있다고 return(false)해주는 입력값을 입력해줘야한다.

    올바르지 않은 벨만포드 알고리즘은 N - 2번 탐색하고 한번 더 탐색해서 값이 업데이트 되면 싸이클이 있다고 판단한다.

처음 생각은 N - 1번째로 업데이트 되게 하면 된다고 생각했지만 곧 가서 의문점이 들었다.

벨만포드 알고리즘은 한번 탐색시 모든 노드들을 순차적으로 돌면서 최단거리를 업데이트 해주는 알고리즘이다. 

따라서 1번 노드부터 N번 노드까지 차근차근 돌면서 N - 1번 업데이트 해주면 최단거리가 나온다.

근데 N - 1번 업데이트 해주는 이유는 뭘까라고 생각해봤는데 쉽게 넘어갈 수 있어도 이는 매우 중요하다

잘 생각해보면 나는 다익스트라 알고리즘을 해결할 때

```java
    for(int i = 0; i <= N; i++){ // 싸이클 판단을 위해 N번 돈다.
        for(int from = 0; from < N; from++){ // 첫번째 노드부터 마지막 노드까지
            if(dist[from] == INF) continue; // 시작 노드부터 현재 노드까지의 거리가 무한일경우 넘어감
            for(Node nextNode : edges.get(from)){ // 현재 노드에 연결되어있는 간선을 모두 살펴봄
                if(dist[nextNode.to] > dist[from] + nextNode.value){
                    dist[nextNode.to] = dist[from] + nextNode.value; // 업데이트
                    isCycle = true; // 싸이클 판단 (이 문제로써는 무방)
                }
            }
        }
    }
```

이런 로직으로 해결한다. 내가 잘 생각해봐야한다고 언급한 이유는

for문의 from을 무조건 0으로 시작하고 시작 노드가 0, 목적지 노드가 마지막 노드일경우

사실 N - 1번 횟수를 돌릴 필요가 없다. 즉 싸이클이 아니고 위와 같은 문제일경우 한번만에 최단거리를 구할 수 있다.

정확히 말하면 한번 반복문을 돌린 후 업데이트가 일어나지 않는다. 아래 그래프를 단계별로 업데이트 하는걸로 설명하겠다.

![image](https://user-images.githubusercontent.com/24482602/163673514-e4d42e91-c6e0-471c-a8d3-580538a17451.png)

하지만 아래와 같이 간단한 그래프더라도 시작 노드가 1(0)이 아닌 3일경우 N - 1번 반복문을 돌려야한다.

![image](https://user-images.githubusercontent.com/24482602/163673589-0743857f-0f13-47de-ba17-bbe36f7bfd0a.png)

**결국 문제마다 시작 노드, 마지막 노드가 다르고 for문은 항상 첫번째 노드부터 돌기 때문에 N - 1번 반복문을 돌린다고 보면 된다.**

나는 편의상 N번 돌려서 cycle을 판단하긴 했다. 벨만포드 알고리즘을 설명하느라 문제 설명을 못하긴 했지만

문제 설명을 좀 해보자면 이 문제는 내가 짠 코드와 좀 다르다 

시작 노드는 존재하지 않고 모든 dist를 0으로 초기화 하고 간선을 기준으로 반복문을 돌렸다.

이와 같은 이유로 N - 1번 반복문을 돌려야한다.

이제 정답에 대해 좀 생각해보자면 N은 여러 값이 존재하고 M또한 여러 값이 존재할 수 있다.

이 문제의 요점은 뭘까?

1. N - 1번째 반복문을 돌렸을 때까지 계속해서 업데이트가 일어나고 N번째는 업데이트가 일어나지 않아야한다.

2. 특정 시작 노드가 정해져 있지 않다. 특정 시작 노드가 정해져 있지 않다면 입력값에 따라 중구난방으로 업데이트가 진행된다.

위와 같은 특성을 생각하면서 입력값을 세가지로 나누어 보자 

    5 4
    1 2 -1
    2 3 -1
    3 4 -1
    4 5 -1
    
    혹은

    5 5
    4 5 -1
    3 4 -1
    2 4 -1
    1 3 -1
    1 2 -1

    혹은
    
    5 4
    4 5 -1
    3 4 -1
    2 3 -1
    1 2 -1

와 같은 dist, 입력 순서, 그래프의 모양만 살짝 다른 예시값을 준비했다.

만약

    5 4
    1 2 -1
    2 3 -1
    3 4 -1
    4 5 -1

입력값으로 이 문제의 코드를 실행할 경우 1번만에 모든 업데이트가 완료된다.

이는 틀린 벨만포드던, 올바른 벨만포드던 계속해서 업데이트가 일어나지 않기 때문에 N - 1번째인지 N - 2번째인지 판단할 수 없다.

두번째로 
    
    5 5
    4 5 -1
    3 4 -1
    2 4 -1
    1 3 -1
    1 2 -1

와 같은 경우 정확이 N - 2(3)번째 만에 업데이트가 끝난다.

우리가 필요한건 N - 1(4)번째 만에 업데이트가 끝나야하고 이는 특정 노드에서 특정 노드까지의 간선이 N - 1개 있어야하고 dist값의 갱신이 한번에 하나씩 이루어져야한다.

이를 만족하는 경우는

    5 4
    4 5 -1
    3 4 -1
    2 3 -1
    1 2 -1

와 같은 입력값이다. 문제의 조건이 50 <= N 이었기 때문에 50부터 시작해준다.

# 2. 새로 배운 내용

<img width="715" alt="스크린샷 2022-04-16 오후 7 37 55" src="https://user-images.githubusercontent.com/24482602/163671779-f53a1679-26e8-4666-8283-781143a0623a.png">

설명하기 좀 까다로운 문제였다.