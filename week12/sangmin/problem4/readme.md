문제 : [골목길](https://www.acmicpc.net/problem/1738)

알고리즘 종류 : 벨만포드

참조 url :

# 1. 알고리즘 설명

벨만포드 알고리즘은 최단거리를 구하는 알고리즘이다.

하지만 골목길 문제는 만약 금품을 거리라고 둘때, 최장거리를 구하는 문제가 된다.

사실 벨만포드로 최장거리를 구할 수 있다. 들어가는 입력값을 양수를 음수로, 음수를 양수로 바꿔주면 최단거리를 구했을 때, -1을 곱해서 출력하면 최장거리가 된다.

따라서 골목길의 입력값을 -1을 곱해서 입력해준다.

여기서 끝났다면 좋았겠지만 골목길이 요구하는 답은 최장거리 경로의 출력과 만약 최단 경로가 존재하지 않는다면 -1을 출력해준다.

일단 경로를 찾기 전에 BFS 알고리즘을 통해 해당 노드가 마지막 노드와 연결되어있는지 판단해줄 필요가 있다.

![image](https://user-images.githubusercontent.com/24482602/163707331-197b76c0-9a76-4183-9078-b6807a1f4e05.png)

목적지가 빨간색으로 칠해진 노드이고 빨간 노드는 시작 노드에서부터 칠해진 노드로 갈때 거치는 노드이다.

파란 노드는 그래프에는 존재하지만 싸이클을 형성하고 있으며 시작 노드에서 마지막 노드로 갈때 거치지 않는다.

이 그래프에서 역방향 그래프를 만들고 마지막 노드에서 BFS혹은 DFS알고리즘을 통해 방문 노드를 체크해준다.

단방향 그래프이기 때문에 방문한 노드와 방문하지 않은 노드가 판단되고, 최단 경로 내에 포함되던 안되던 간에 일단 이 노드는 마지막 노드까지 연결되어 있다.

이제 벨만포드 알고리즘을 돌려주면 되는데 여기서 parent배열을 준비해야한다.

parent 배열이 의미하는것은 해당 idx의 부모 노드가 parent[idx]라는 뜻이다.

parent[idx]를 각각 idx로 초기화 해주고 시작 노드가 1이기 때문에 1의 parent만 0으로 설정해준다.

이제 벨만포드 알고리즘을 N - 1번 돌면서 각각 최단거리를 업데이트 해주면 되는데, 이 때 dist[to]가 업데이트 될 경우 parent[to] = from으로 업데이트 해준다.

dist[to]가 업데이트 될 경우는 dist[from] + from에서 to로 가는 비용이 dist[to]보다 작을때기 때문에 to의 부모를 from으로 업데이트 해준다.

그리고 마지막으로 벨만포드를 돌릴때, 기존에는 모든 업데이트에서 싸이클을 판단했지만 앞서 실시했던 BFS에 방문했던 노드가 업데이트 될경우(싸이클일경우) 이 문제의 정답은 -1이 된다.

당연히 마지막 노드와 연결되어있는 노드 중 하나라도 싸이클에 포함될경우 마지막 노드의 값을 구할 수 없다.

만약 싸이클이 아니라고 판단될 경우 우리는 각각 어떤 노드가 어떤 부모에 연결되어 있는지 알 수 있다.

parent[N]부터 시작해서 parent[idx]의 값이 0이 될때까지 리스트에 넣어주고 뒤집어준 후 출력하면 정답이 된다.

# 2. 새로 배운 내용

<img width="577" alt="스크린샷 2022-04-17 오후 5 16 28" src="https://user-images.githubusercontent.com/24482602/163706630-6bf80706-ce1d-4159-8870-dc5eac31305a.png">

틀렸습니다... 틀렸습니다... 틀렸습니다...

죄송합니다... 죄송합니다... 죄송합니다...
