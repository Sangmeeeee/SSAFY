# Info

문제 : [벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)

알고리즘 종류 : BFS

참조 url : https://ongveloper.tistory.com/124


# 1. 알고리즘 설명
처음에는 모든 벽에 대해 그 벽을 없애고 너비 우선 탐색을 진행했다. 예상은 했지만 역시나 시간 초과...

그래서 bfs를 돌면서 벽을 하나씩 없애보려고 했는데 잘 안돼서 다른 사람 코드를 참고했다.

방문 여부 확인과 동시에 **이동 거리를 저장하는 3차원 int형 배열**과 **3가지 정보를 저장하는 큐**를 사용하여 해결할 수 있었다.


### 사용 변수
1. `vector<vector<vector<int>>> visited`
	- 방문 여부를 체크하는 변수이며, 3차원 int형 배열로 선언한다.
	- 여태까지 **이동한 거리를 저장**한다.
2. `queue<tuple<int, int, int>> q`
	- `bfs` 함수 안에서 쓰이며, tuple로 3가지 정보를 저장한다.
	- **x좌표, y좌표, 현재 벽을 부술 수 있는 상태인지(이미 이전에 벽을 부쉈다면 0, 아니면 1)**


### 전체적인 풀이 방법
큐가 빌 때까지 너비 우선 탐색을 한다.

1. 큐를 pop하여 x좌표와 y좌표, 현재 벽을 부술 수 있는지에 대한 정보를 가져온다.
2. x좌표와 y좌표가 도착 지점과 같다면 현재 위치에 대한 `visited` 값, 즉 이동 거리를 반환한다.
	- 사방탐색 이전에 해주는 이유는 지도가 한칸짜리(`r`=1, `c`=1)일 수 있기 때문이다.
3. 사방탐색을 한다.
	1. 다음에 이동할 위치에 벽이 있고, 현재 벽을 부술 수 있는 상태이면
		- 큐에 위치 정보와 0(더이상 벽을 부술 수 없는 상태)을 저장한다.
		- `visited` 배열에서 이동할 위치의 3차원 값이 0인(벽이 부서진 상태) 곳에 현재 위치의 `visited`값 + 1을 저장한다.
	2. 다음에 이동할 위치에 벽이 없고, 아직 방문하지 않은 곳이라면
		- 큐에 위치 정보와 벽 상태를 저장한다.
		- 이동할 위치의 `visited` 배열에 현재 위치의 `visited`값 + 1을 저장한다.
4. 도중에 return 되지 않았다면 도착 지점으로 갈 수 없다는 뜻이므로 -1을 반환한다. 


# 2. 새로 배운 내용(코드 위주)
