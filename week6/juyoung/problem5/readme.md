# Info

문제 : [저울](https://www.acmicpc.net/problem/2437)

알고리즘 종류 : 그리디

참조 url : 


# 1. 알고리즘 설명

하루종일 고민했는데 그냥 정렬시키고 앞에서부터 더하다가 얼떨결에 풀렸다.

1. 측정할 수 없는 양의 정수 무게 중 **최솟값**이므로 오름차순 정렬 후 풀어야 한다.
2. 어떤 수 `start`까지 측정할 수 있는지 검사하기 위해
	1. `start`는 1부터 시작한다. 즉, 1까지 측정할 수 있는지부터 차례로 검사한다.
	2. `start`와 추의 무게가 저장된 배열의 값 `weight[i]`를 비교한다.
		1. `start`가 `weight[i]`보다 작다면 `start`를 측정할 수 없다는 뜻이다.
			- 반복문을 빠져나간다.
		2. `start`가 `weight[i]`보다 크거나 같다면 `start`를 측정할 수 있다는 뜻이다.
			- `start`에 `weight[i]`를 더한다.
3. `start`에 마지막으로 저장된 수가 측정할 수 없는 최솟값이다.

### 예시
문제에서 주어진 예시 입력1을 정렬하면 다음과 같이 된다.
```
1 1 2 3 6 7 30
```
처음에는 `start`가 1이다.

`start`까지, 즉 1까지 측정할 수 있는지를 검사해야 하는데 이때 `weight[0]`부터 차례대로 검사해준다.

`weight[0]`은 1이고, `start`와 같기 때문에 `start`에 `weight[0]`을 더한다.

그럼 `start`는 2가 되고, 이 말은 1까지는 측정할 수 있다는 뜻이다.

그 이후에도 아래와 같이 된다.

- `start=2` > `weight[1]=1` 따라서 `start=3`
- `start=3` > `weight[2]=2` 따라서 `start=5`
- `start=5` > `weight[3]=3` 따라서 `start=8`
- `start=8` > `weight[4]=6` 따라서 `start=14`
- `start=14` > `weight[5]=7` 따라서 `start=21`
- `start=21` < `weight[6]=30` 따라서 break

그래서 마지막으로 `start`에 저장된 21이 정답이 된다.



# 2. 새로 배운 내용(코드 위주)
