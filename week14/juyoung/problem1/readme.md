# Info

문제 : [전화번호 목록](https://www.acmicpc.net/problem/5052)

알고리즘 종류 : 트라이

참조 url : 


# 1. 알고리즘 설명

1. 트라이 생성
2. 트라이에 모든 문자열 삽입
3. 트라이에서 각 문자열 검색

위와 같이 풀이는 간단한데 트라이라는 자료구조를 처음 써봐서 생소했다!  
트라이에 대한 내용은 아래에...


# 2. 새로 배운 내용(코드 위주)
## 트라이(TRIE)
[참고](https://eun-jeong.tistory.com/29)

트라이는 **문자열을 효율적으로 저장하고 탐색할 수 있는 자료구조**이며 기본적으로 K진 트리의 구조를 띤다.  
트라이는 직접 정의해서 사용하는 자료구조이며 보통 아래와 같이 구성되어있다.  

1. 문자열이 끝나는 지점을 체크하는 변수  
2. 각 노드를 가리키는 포인터 배열  
3. 생성자와 소멸자  
4. 삽입하는 함수  
5. 문자열을 찾는 함수  

포인터 배열은 문제의 입력 문자열이 무엇으로 이루어져 있냐에 따라 할당하는 크기가 달라진다.  
만약 숫자로 이루어진 문자열이라면 0부터 9까지 총 10만큼을 할당하면 되고  
영어 소문자로 이루어진 문자열이라면 a부터 z까지 총 26만큼을 할당하면 된다. 
내가 이번 문제에 적용시킨 트라이의 구조도 아래와 같다.   

```cpp
struct TRIE {
	bool finish;	// 1. 문자열이 끝난 지점에서 true로 체크
	TRIE *node[10]; // 2. 각 숫자 노드를 가리키는 포인터 배열

	// 3. 생성자와 소멸자
	TRIE() {
		finish = false;
		for (int i = 0; i < 10; i++) node[i] = NULL;
	}
	~TRIE() {
		for (int i = 0; i < 10; i++) delete node[i];
	}

	// 4. 삽입하는 함수
	void insert(char *str) { //... }

	// 5. 문자열을 찾는 함수
	bool find(char *str) { //... }
};
```

제일 먼저 `root`라는 이름의 트라이를 생성하고, 이 트라이에 문자열을 하나씩 십압하게 된다.  
아래와 같이 트라이를 처음 생성했을 때 트라이의 생성자가 호출되면서 포인터 배열이 전부 NULL로 초기화된다.  
```cpp
TRIE *root = new TRIE();
```

이후 문자열 입력과 동시에 트라이에 문자열을 삽입하는데, 삽입 함수는 다음과 같다.  
```cpp
void insert(char *str) {
	// 1. 만약 문자열의 끝이라면 finish를 true로 체크
	if (*str == NULL) {
		finish = true;
		return;
	}

	// 2. 현재 숫자에 대해 노드가 존재하는지 체크하고 없으면 생성
	int curr = *str - '0';
	if (node[curr] == NULL) node[curr] = new TRIE();
	// 3. 다음 글자를 삽입한다.
	node[curr]->insert(str + 1);
}
```
삽입 시에는 포인터를 사용하여 한 글자씩 노드를 생성하며 삽입하게 된다.  
위 주석을 차례대로 따라가보면  
1. 현재 문자가 NULL이라면, 즉 문자열이 끝났다면 현재 노드의 `finish`를 `true`로 갱신한다.
2. 현재 문자에 대해 노드가 존재하지 않는다면 포인터 배열에서 현재 문자의 인덱스를 찾고 새로운 노드(트라이)를 생성한다.
3. 현재 문자에 대한 노드에 다음 글자를 삽입한다.

삽입 연산이 모두 끝나면, 생성된 트라이를 통해 모든 문자열에 대해 다른 문자열의 접두어 여부를 검사한다.  
이때 `find()` 함수를 사용하고 `find()` 함수는 다음과 같다.  
```cpp
bool find(char *str) {
	// 마지막 문자에 도달한다면 일관성 O
	if (*str == NULL) return true;
	// 공유하는 노드 중 문자열의 끝을 나타내는 노드가 있으면 일관성 X
	if (finish) return false;

	int curr = *str - '0';
	// 다음 문자를 찾는다.
	return node[curr]->find(str + 1);
}
```

각 문자열 `numbers[i]`에 대해 `root->find(numbers[i])`를 호출하는데,  
위 코드와 같이 `*str==NULL`이면 노드를 타고타고 들어가서 문자열의 마지막에 도달한 것이다.  
이때는 해당 문자열이 다른 문자의 접두어가 아니므로 `true`를 리턴한다.

`finish`가 `true`인 경우는, 해당 노드가 어떤 문자열의 끝에 해당한다는 뜻이 된다.  
이때는 그 문자열이 다른 문자열의 접두어가 된다는 것으로, `false`를 리턴한다.  

예를 들어 문제의 예제 입력 1에 따라 생성된 트라이는 다음과 같이 구현되어 있을 것이다.  
![KakaoTalk_20220425_221831202](https://user-images.githubusercontent.com/57346428/165108707-5337a1d8-64c3-4aa7-b09d-450998d47bc1.jpg)

이때 제일 위의 빈 노드가 `root`이며 입력을 통해 `root` 노드의 포인터 배열 중 `9`에 대해 노드가 생성된다.  
나머지 노드들도 아래로 쭉 생성되는데, 만약 `911`을 찾고자 한다고 가정하자.  
그럼 위 그림에서 root -> 9 -> 1 -> 1 순으로 타고 들어가게 될 것이고, `finish`가 `true`인 노드를 만나게 된다.  
그렇기 때문에 이 예제에서는 `find()` 함수에서 `false`가 리턴되어 `NO`를 출력한다.  

마지막에는 `delete root`를 통해 생성한 트라이를 소멸시켰다.  
소멸시켰을 때와 안 시켰을 때 메모리가 10배 넘게 차이나서 놀랐다.  
아래 캡처에서 위에서부터 차례대로 소멸시키지 않은 코드, 포인터 배열의 크기가 10인 코드,  
그리고 마지막은 처음에 실수로 포인터 배열의 크기를 소문자 알파벳 개수만큼(26) 할당했을 때의 코드이다.  
![화면 캡처 2022-04-25 234845](https://user-images.githubusercontent.com/57346428/165114186-0c1dc8e5-858d-47b4-9897-8f75874ef24e.jpg)


### 시간 복잡도, 공간 복잡도
문자열의 최대 길이가 `M`일 때, 문자열을 트라이에 삽입하는 `insert()`와  
트라이에서 문자열을 검색하는 `find()` 모두 문자열의 길이(트리의 최대 높이) 내로 끝나기 떄문에  
**O(M)**라는 효율적인 시간 복잡도를 가진다.  

하지만 각 노드에 다음 문자를 가리키기 위한 포인터 배열이 있어야 하기 때문에  
**`O(포인터의 크기*포인터 배열의 개수*트라이에 존재하는 총 노드의 개수)`**라는 큰 공간 복잡도를 가진다.  