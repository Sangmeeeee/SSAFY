# Info

문제 : [생태학](https://www.acmicpc.net/problem/4358)

알고리즘 종류 : 트라이

참조 url : 


# 1. 알고리즘 설명

트라이 연습 문제였지만 나무 종류별 개수를 알아야 한다는 점과 사전 순으로 출력해야 한다는 점에서 **map**으로 풀었다.

입력될 때마다 map에서 그 나무의 종류에 대한 개수를 1씩 증가시키고 `iterator`로 map을 차례로 조회하며  
각 종의 이름과 그 종이 차지하는 비율을 백분율로 소수점 넷째자리에서 반올림한 수를 출력한다.


# 2. 새로 배운 내용(코드 위주)

이 문제에서 헷갈렸던 점은 **어떻게 EOF까지 입력을 받는지**와 **어떻게 소수점 넷째자리에서 반올림을 하는지**였다.  
따로 입력받는 문자열의 개수가 정해져있지 않았기 때문에 찾아봤더니 EOF까지 입력받으려면 아래와 같이하면 된다고 한다.  
```cpp
string s;
while(getline(cin, s)) {
	// ...
}
```  
테스트 시에는 입력 제일 마지막에 Ctrl+Z를 입력하고 엔터를 치면 정상적으로 실행된다.

그리고 C++에서는 반올림을 하는 방법이 크게 세가지가 있는 것 같다.  

1. `<cmath>` 헤더의 `round()` 함수 사용하기
2. `<cmath>` 헤더의 `floor()` 내림 함수를 이용하여 반올림 구현하기
3. `cout << fixed`와 `cout.precision()` 사용하기

첫번째 방법은 n번째 자리를 지정하여 반올림하는 것이 불가능하고, 첫째 자리에서만 반올림이 가능하다.  
따라서 소수점 n번째 자리에서 반올림을 하려면  
소수점 n번째 자리를 직접 소수점 첫째 자리로 만들고, 반올림한 이후 원상태로 복구해야 한다.

```cpp
// 12.34567을 소수점 넷째자리에서 반올림하기
double num = 12.3456;
num = round(num*1000) / 1000.0;
```

또한 이 방법은 C++11에서 지원을 한다고 한다!  

두번째 방법도 마찬가지로 n번째 자리를 지정하는 것이 불가능한데,  
`floor(N+0.5)`를 하면 소수점 첫째 자리를 기준으로 반올림이 된다.  

마지막이 이번 문제에서 내가 코드에 적용한 방법인데, 이번에 처음 알았다.  
`cout << fixed`를 통해 소수점 이하의 자릿수만을 다룰 수 있게 설정하고,  
`cout.precision(4)`를 통해 총 4자리를 다루도록 설정할 수 있다.  
만약 `fixed` 설정을 하지 않는다면, 정수와 소수를 합쳐서 총 4자리를 나타낼 수 있지만(X.XXX, XX.XX, XXX.X)  
`fixed` 설정을 해주었기 때문에 소수점 아래의 4자리 수(.XXXX)를 나타낼 수 있게 된다.  