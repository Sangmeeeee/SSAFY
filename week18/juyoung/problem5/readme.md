# Info

문제 : [양궁대회](https://programmers.co.kr/learn/courses/30/lessons/92342)

알고리즘 종류 : 

참조 url : 


# 1. 알고리즘 설명

라이언이 화살을 쏠 수 있는 모든 경우의 수를 구하고, 그 안에서 점수를 계산해줬다.  
그러기 위해 `shoot()` 함수를 정의했고, 모든 경우의 수를 구할 때까지 재귀적으로 호출했다.

라이언은 i점에 대해 다음 두 가지 경우에 처할 수 있다.
1. 어피치가 i점에 쏜 화살의 개수+1개보다 라이언이 가진 화살의 개수가 많거나 같은 경우
2. 어피치가 i점에 쏜 화살의 개수+1개보다 라이언이 가진 화살의 개수가 적은 경우

1의 경우에는 어피치가 쏜 화살의 개수보다 1개를 더 쏘면 된다.  
2의 경우에는 가지고 있는 모든 화살을 쏴도 점수를 딸수 없으므로 화살을 낭비하지 않고 넘어갸아 한다.

그리고 이렇게 10점부터 1점을 지나, 만약 0점에 도달한다면 이후에는 쏠 수 있는 점수가 없으므로  
가지고 있는 모든 화살을 0점에 쏘아야 한다.

위 경우들을 고려하여 코드를 짜면 `shoot()`은 아래 과정과 같다.
1. 라이언이 쏠 수 있는 화살을 다 쐈다면 점수를 계산한다.
    1. 라이언과 어피치의 점수를 각각 구한다.
    2. 현재 최대 점수 차이보다 라이언의 점수-어피치의 점수가 크다면
        - 정답과 최대 점수 차이를 업데이트한다.
    3. 현재 최대 점수 차이와 라이언의 점수-어피치의 점수가 같다면 (*)
        - 현재 정답으로 저장된 배열과 라이언이 쏜 점수에 대한 배열을 비교한다.
        - 둘 중 가장 낮은 점수를 더 많이 맞힌 경우를 선택한다.
        - 현재 라이언이 쏜 것이 낮은 점수를 더 많이 맞힌 경우라면 정답을 업데이트한다.
2. 10점부터 0점까지 차례로 어피치가 쏜 배열을 검사한다.
    1. 현재 점수가 0점이라면 라이언이 가진 남은 화살을 전부 쏜다.
    2. 그렇지 않다면 어피치가 현재 점수에 쏜 화살의 개수+1과 라이언이 가진 화살의 개수를 비교한다.
        - 후자가 더 많거나 같다면 어피치보다 1개 더 많이 쏜다.
        - 전자가 더 많다면 `continue`하여 넘긴다.
    3. `shoot()` 함수를 재귀적으로 호출한다.
    4. 재귀적으로 호출한 작업이 끝나면, 라이언이 쏜 점수에 대한 배열을 원상복구 한다.

위 과정에서 "화살을 쏜다"는 것은, 라이언에게 남은 화살 개수를 업데이트 하고,  
라이언이 현재 쏜 점수에 대한 배열에서 해당 점수에 해당하는 부분을 쏜 화살 개수로 업데이트 하는 것을 의미한다.  

처음에 (*)로 표시한 부분(1-iii)을 처리해주지 않아서 8번, 18번 케이스가 fail이 떴다.  
그냥 최대 점수 차이가 크거나 "같을" 때 정답을 업데이트 해주면  
알아서 가장 낮은 점수를 많이 맞춘 쪽이 저장된다고 생각했는데 아니었다...!


# 2. 새로 배운 내용(코드 위주)
