# Info

문제 : [개똥벌레](https://www.acmicpc.net/problem/3020)

알고리즘 종류 : 이분탐색, 누적 합

참조 url : 


# 1. 알고리즘 설명

서로 다른 배열에 석순과 종유석의 높이를 입력 받고, 1부터 H까지의 구간을 탐색하며 **lower bound**와 **upper bound**로 이분 탐색을 한다.

1. `top` 배열과 `bottom` 배열에 각각 석순과 종유석의 높이를 입력 받는다.
2. 이분탐색을 위해 `top` 배열과 `bottom` 배열을 정렬한다.
3. `h`가 1부터 H일 때까지(아래에서 위로) 탐색하며 각 구간에 있는 장애물의 개수를 카운트한다.
    1. 석순은 `lower_bound()`를 통해 `h` 이상의 값이 나오는 인덱스(`idx`)를 찾는다.
        1. ex) 네번째 구간(`h`=4)이면 석순의 높이가 4 이상이 되는 인덱스를 찾는다.
        2. 석순의 높이를 오름차순으로 정렬했으므로 해당 인덱스 이후부터는 전부 해당 구간의 장애물이 되기 때문에 배열의 길이에서 해당 인덱스를 뺀 값(`N/2-idx`)만큼 카운트한다.
    2. 종유석은 `upper_bound()`를 통해 `H-h`를 초과하는 값이 나오는 인덱스를 찾는다.
        1. ex) 높이가 7이고 네번째 구간(`h`=4)이면 종유석의 높이가 3을 초과하는 인덱스를 찾는다. 종유석은 거꾸로 달려있기 때문에 네번째 구간의 장애물이 되려면 높이가 3을 초과해야 한다.
        2. 종유석 또한 높이를 오름차순으로 정렬했으므로 해당 인덱스 이후부터는 전부 해당 구간의 장애물이 되기 때문에 배열의 길이에서 해당 인덱스를 뺀 값을 카운트한다.
4. 파괴해야 하는 장애물의 최솟값(`minimum`)과 카운트한 값(`c`)을 비교한다.
    1. `minimum`보다 `c`가 작다면, `minimum`을 `c`로 업데이트 해주고 그러한 구간의 수(`count`)를 1로 업데이트 한다.
    2. `minimum`과 `c`가 같다면, `count`를 1만큼 증가시킨다.


# 2. 새로 배운 내용(코드 위주)

### lower_bound, upper_bound

1. **lower_bound**
	- 찾으려는 key 값보다 **같거나 큰 숫자**가 배열의 몇 번째에서 처음 등장하는지 찾을 때 사용한다.

		```cpp
		// arr에서 3 이상의 숫자가 처음으로 나오는 인덱스 번호 반환
		int arr[5] = { 1, 2, 3, 4, 5 };
		int idx = lower_bound(arr, arr+5, 3) - arr;
		```

2. **upper_bound**
	- 찾으려는 key 값을 **초과하는 숫자**가 배열의 몇 번째에서 처음 등장하는지 찾을 때 사용한다.
		
		```cpp
		// arr에서 3을 초과하는 숫자가 처음으로 나오는 인덱스 번호 반환
		int arr[5] = { 1, 2, 3, 4, 5 };
		int idx = upper_bound(arr, arr+5, 3) - arr;
		```
    
* 주의사항
	- 탐색을 진행할 배열 혹은 벡터는 **오름차순으로 정렬**돼 있어야 한다.
	- `lower_bound`와 `upper_bound`의 반환형은 iterator이므로 실제로 몇 번째 인덱스인지 알고 싶다면, 배열이나 벡터 첫 번째 주소를 빼줘야 한다.


- [참고](https://chanhuiseok.github.io/posts/algo-55/)
