# Info

문제 : [단어 변환](https://programmers.co.kr/learn/courses/30/lessons/43163)

알고리즘 종류 : DFS

참조 url :


# 1. 알고리즘 설명

최근에 풀었던 문제들과 비슷해서 풀이 방법을 생각해낸 이후에는 금방 코드를 짤 수 있었다.

단순히 문자열로도 풀리는지는 모르겠지만 복잡할 것 같아서 DFS를 사용했다.

### 전체적인 풀이 방법
1. 인접리스트를 만들고, 이를 깊이 우선 탐색하며 depth를 세아린다.
2. 어떤 노드를 방문했을 때 `words[노드]` 값이 `target`과 같다면 depth를 반환한다.

### 그래프를 만든 방법
1. `words` 배열의 가장 앞에 `begin`을 삽입한다.
	- `begin`을 시작 노드로 삼기 위함이다.
2. words 배열에서 2개를 뽑은 모든 조합에 대해 두 단어 간 서로 다른 알파벳이 1개라면 서로를 인접리스트에 추가한다.

예를 들어, 문제의 첫번째 예시 같은 경우 아래와 같은 인접리스트 및 그래프가 만들어진다.

(`begin` = "hit", `target` = "cog", `words` = ["hot", "dot", "dog", "lot", "log", "cog"])

![KakaoTalk_20220217_200336797](https://user-images.githubusercontent.com/57346428/154470294-8e575085-6a59-4325-a0dc-070e4bdc49c4.jpg)

인접리스트를 만들 때 모든 단어들을 서로 비교하고, 그 안에서 또 단어의 길이만큼 비교하기 때문에 실행 시간이 오래 걸릴까 걱정했지만 입력 제한값이 작아서 괜찮았다.

# 2. 새로 배운 내용(코드 위주)
