# Info

문제 : [휴게소 세우기](https://www.acmicpc.net/problem/1477)

알고리즘 종류 : 이분탐색

참조 url : https://gusdnr69.tistory.com/277


# 1. 알고리즘 설명

휴게소 간의 거리가 `mid`인 경우 세워질 수 있는 휴게소의 개수를 카운트하며 이분탐색했다.

1. 시작 지점인 0과 끝 지점인 L을 포함하여 배을 입력 받은 후 정렬한다.
2. 정렬한 배열에 대해 이분탐색을 진행한다.
    1. `low`의 초기값은 1, `high`의 초기값은 L이다.
    2. 휴게소 간의 거리를 `mid`라고 했을 때, **각 구간에 세워질 수 있는 휴게소의 개수**(`cnt`=연속한 휴게소 간의 거리/`mid`)를 카운트한다.
        1. 카운트한 개수 `cnt`가 짓고자 하는 휴게소의 개수 `M`보다 크다면 `low`를 `mid+1`로
        2. 그 반대라면, 즉 `cnt`가 `M`보다 작거나 같다면 `high`를 `mid-1`로 설정하며 이분탐색한다. 이때, 정답 변수 `answer`에 `mid`를 저장해준다. 
    3. 이때 주의할 점은 연속한 휴게소 A와 B간의 거리를 `mid`로 나눴을 때 **딱 나누어 떨어진다면**, 이미 B가 지어져 있는 자리도 해당 구간에 세워질 수 있는 휴게소의 개수 `cnt`에 포함되므로 `cnt`의 값을 1만큼 감소시켜야 한다.


### 풀이 그림

![KakaoTalk_20220216_224449246](https://user-images.githubusercontent.com/57346428/154277398-3a209189-ae5f-474d-89d1-52272e5b0a38.jpg)


### 틀린 이유

1. 처음 풀이 - 우선순위 큐
    - 처음에는 우선순위 큐로 풀었는데, 무식하게 가장 긴 구간의 중간 지점에 계속해서 휴게소를 세운다고 생각했다. 하지만 그런 경우 아래와 같은 문제가 발생했다.
        
        ![KakaoTalk_20220216_165149944](https://user-images.githubusercontent.com/57346428/154277394-80e2e9ef-4321-4c6d-8106-5d0f18b20c34.jpg)
        
        201~411 구간이 현재 가장 긴 구간이라고 가정했을 때 좌측의 경우 해당 구간을 2로 나눈 지점에 휴게소를 세운다. 만약 그 후에도 길이가 105인 구간이 가장 긴 구간일 때, 이를 또 2로 나눈 지점에 휴게소를 세운다. 여기서 더 이상 지을 수 있는 휴게소가 없다면, 가장 긴 구간의 길이는 105가 된다.
        
        하지만 우측과 같이 지을 수 있는 휴게소 사이의 구간이 1:1로 비례되도록 나누어야 최대 구간의 길이를 최소로 만들 수 있다. 
        
        그래서 이건 이분탐색으로 풀어야겠구나.. 하고 다른 사람 코드를 참고해서 다시 코드를 작성했다.
        
2. 두번째 풀이 - 이분탐색, **division by zero 에러**
    - 1 7 10 / 1
    - 위와 같은 입력이 주어졌을 때, 가장 짧은 구간의 길이가 1이 되면서 high가 한없이 작아져서 결국 mid가 0이 되고, 각 휴게소 간의 거리를 mid로 나눌 때 division by zero 에러가 발생했다.
    - 해결하기 위해서 혼자 여러 상황을 대입해보며 mid가 0이 될 때는 L-(N+M)을 출력하고 break하도록 했는데, 그래도 틀렸다.
    - 제규님이 도움을 받아 확인해보니 휴게소 간의 거리는 최소 1 이상이므로 처음부터 low의 값을 1로 초기화하면 되는 문제였다...!


# 2. 새로 배운 내용(코드 위주)
