문제 : [장난감 조립](https://www.acmicpc.net/problem/2637)

알고리즘 종류 : 위상정렬, dp

참조 url : 

# 1. 알고리즘 설명

처음에는 dfs로 해결하려 했지만 시간초과가 나서 원래 알고리즘 분류인 위상정렬로 해결해주었다.

내 생각에는 dfs로 해도 100 * 100의 시간이라 시간 초과가 나지 않을것 같은데 뭔가 오류가 있는 것 같다.

위상정렬에 dp까지 사용해야 해결할 수 있는 문제이다. dp[i][j]는 node i를 만들기 위해 필요한 j의 개수를 저장한다.

기본 부품에서 시작하는게 아닌 완제품은 하나기 때문에 완제품에서 역으로 거슬러 올라가며 기본 제품의 개수를 구한다.

문제에서 나온 예시를 보자면 제품 7에서 제품 6은 3개, 제품 4는 5개, 제품 5는 2개가 필요하다.

큐에 제품 7을 넣어주고 연결되어있는 inDegree를 관리한다.

현재 노드가 7일경우 dp[7][nextNode]의 입력을 이미 해놨기 때문에 dp[7][nextNode]의 업데이트는 일어나지 않는다.

dp[7][5] += dp[7][5] * dp[7][7] = (dp[7][5] + 0)

7과 연결되어있는 노드들의 inDegree가 0일경우에 큐에 넣으면 큐에는 6, 4가 들어가있다.

그 후 6과 연결되어있는 노드들을 살펴보면서 dp[7][nextNode]를 업데이트 해준다.

6번 노드에는 5번 노드 2개, 3번 노드 3개, 4번 노드 4개가 연결되어 있다.

7번 노드에서 6번 노드로 가기위해선 3개가 필요하고 6번 노드에서 5번 노드로 가기위해선 2개가 필요하니까 총 6개가 필요하다.

dp[7][5] += dp[7][6] * dp[6][5]를 해준다.

해당 작업을 모든 노드에 대해서 위상정렬 알고리즘을 통해 방문 순서대로 해주면

모든 노드에 대해서 7번 제품이 생성될 때 필요한 개수가 나온다.

필요한 개수에서 기본 제품들(다음으로 가는 간선이 없는 노드)만 골라서 출력해준다.

# 2. 새로 배운 내용