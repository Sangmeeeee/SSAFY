# Info

  

문제 : [작업](https://www.acmicpc.net/problem/2056)

알고리즘 종류 : 위상정렬

참조 url : 

  

# 알고리즘 설명
현재 하고 있는 작업의 종료 시간은 이전에 완료해야 했던 작업들 중에서 가장 늦게 끝난 작업의 종료 시간에 현재 작업에 걸리는 시간을 더한 것이다.  

`graph` - 작업 순서에 대한 인접리스트  
`u` - 이전 작업 중 하나  
`v` - 현재 작업  
`endTime` - 각 작업의 종료 시간을 저장하는 배열  
`time` - 각 작업을 완료하는데 걸리는 시간을 저장하는 배열 

위와 같이 정의했을 때 현재 작업의 종료 시간은 다음과 같다.
```c++
endTime[v] = max(endTime[u] + time[v], endTime[v]);
```
전체 종료 시간은 다음으로 연결된 작업이 없는 작업들의 종료 시간 중에서 최대값이 된다.  
즉, `graph[u].size() == 0`일 때 현재 최소값과 종료 시간을 비교해서 갱신해주면 된다.
```c++
ans = max(endTime[u], ans);
```

# 새로 배운 내용
처음에는 현재 동시에 하고 있는 작업 중에서 걸리는 시간이 가장 큰 작업의 시간을 구해서 다 더했는데 틀렸다. 다음과 같은 반례를 예로 들 수 있다.  

<img src="https://user-images.githubusercontent.com/55791128/158758703-5e87e2e3-9876-4f11-99f6-329f7ce26406.jpg" width=350>  

실제 종료 시간은 21인데 위의 방식대로 하면 22가 나온다.  
3번 작업은 4번 작업과 관련이 없어서 영향을 주어서는 안되므로 내가 처음에 했던 방법은 잘못된 방법이라고 할 수 있다.
