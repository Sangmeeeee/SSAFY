# Info

문제 : [세부](https://www.acmicpc.net/problem/13905)

알고리즘 종류 : 분리 집합

참조 url : 


# 1. 알고리즘 설명

**크루스칼 알고리즘**과 **DFS**를 사용하여 풀었다.

:tulip: **접근**  
DFS로만 문제를 푼다면, 탐색하는 횟수가 억대가 되기 때문에  
크루스칼 알고리즘을 통해 MST를 만든 후 그래프를 탐색해야 한다.  

:tulip: **입력**  
들고 갈 수 있는 금빼빼로의 *최소*가 아닌 *최대* 개수를 알아내야 하므로  
다리의 정보를 입력받을 때 무게 제한에 `-1`을 곱한 수를 저장한다.  

:tulip: **풀이**  
*크루스칼 알고리즘*을 수행하기 위해 각 노드의 루트 노드를 저장하는 배열을 선언 및 초기화한다.  
그리고 입력 받은 간선을 무게 제한(-1을 곱한 것)을 기준으로 오름차순 정렬한다.  
이후 무게 제한이 가장 작은 것부터 차례대로 간선을 연결한다.  
만약 두 정점을 연결했을 때 사이클이 생긴다면, 즉 두 정점의 부모 노드가 같다면 연결하지 않는다.  
반대로 사이클이 생기지 않는다면 두 정점을 연결하고, DFS 수행을 위한 새로운 인접리스트를 생성한다.  

*DFS*를 수행한다.  
새로 생성한 인접리스트를 바탕으로 그래프를 탐색하며 `dist` 배열에 현재 depth의 무게 제한을 저장한다.  
도착 지점에 도달했을 때, `dist`에 저장된 무게 제한 중 최소값을 `answer` 변수에 저장하며  
연쇄적으로 return하여 `main()` 함수에서 `answer`를 출력한다.  

하나 주의해야 할 점은, 출발 정점에서 도착 정점까지 도달할 수 없는 경우가 있을 수 있다는 것이다.  
따라서 만약 `answer`가 처음 초기화했던 `1e9`와 같다면 0을 출력한다.  



# 2. 새로 배운 내용(코드 위주)