# Info

문제 : [중량제한](https://www.acmicpc.net/problem/1939)

알고리즘 종류 : 분리 집합

참조 url : 


# 1. 알고리즘 설명

백준 13905 세부 문제와 비슷한 문제로,  
각 간선의 중량(무게) 제한이 주어지고 출발지에서 도착지까지의 최대 중량을 구하는 문제였다.

13905 문제와 마찬가지로 **크루스칼 알고리즘**과 **DFS**를 이용하여 풀었다.

:tulip: **입력**  
크루스칼 알고리즘은 최소 스패닝 트리를 만들기 위해 간선의 weight를 기준으로 오름차순 정렬이 필요한데,  
이 문제에서는 `최솟값`이 아닌 `최댓값`을 구하고자 하므로 입력 시 중량 제한에 `-1`을 곱한 값을 저장했다.

:tulip: **풀이**  
크루스칼 알고리즘 없이 DFS만 돌린다면 시간 초과가 날 게 분명했다.  
그래서 크루스칼 알고리즘을 통해 MST를 구해서 간선의 수를 줄이고자 했다.  
저장한 중량 제한을 기준으로 오름차순 정렬한 후 사이클이 만들어지지 않도록 차례대로 연결한다.  
이때 유니온파인드를 사용했으며, 동시에 DFS를 위한 인접리스트도 생성했다.  

이후 DFS를 수행하는데, 생성한 인접리스트를 차례로 방문하며 각 `depth`별로 배열에 중량 제한을 저장한다.  
만약 공장이 위치한 다른 섬에 도착했다면 `depth`별로 저장된 배열을 탐색하며 중량 제한 중 최솟값을 찾는다.  

마지막으로 정답을 출력하는데, 이때 정답 `answer`가 처음 초기화한 값과 같다면  
공장이 위치한 두 섬이 서로 도달할 수 없다는 의미이므로 0을 출력하고 그렇지 않으면 `answer`를 출력한다.  

:tulip: **틀린 이유** 
처음에 `answer`를 `1e9`로 초기화해놨었는데, 알고보니 문제에서 주어진 중량 제한 최댓값이 `1e9`였다.  
그래서 정답이 `1,000,000,000`일 때 `answer`가 초기값에서 변경된 게 없다고 판단하고 0을 출력한 거였다...  
`answer`의 초기값을 `1e9*2`로 변경해줬다. 로직 문제가 아니어서 다행이었다...  


# 2. 새로 배운 내용(코드 위주)