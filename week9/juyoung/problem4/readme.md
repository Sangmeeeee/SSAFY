# Info

문제 : [색상환](https://www.acmicpc.net/problem/2482)

알고리즘 종류 : DP

참조 url : 


# 1. 알고리즘 설명

`dp[i][j]` = j개 중 서로 인접하지 않는 i개를 선택하는 경우의 수  
`dp[0][j]` = 0개를 선택하는 경우의 수는 1개이므로 1로 초기화한다.  
`dp[1][j]` = j개 중 1개를 선택하는 경우의 수는 j개와 같으므로 j로 초기화한다.

`dp[2][j]`, 즉 2개 이상을 고르는 것부터는 2가지 경우로 나누어서 볼 수 있다.
1. `j`번째 색을 선택하는 경우
	- `j`번째 색을 선택하면 `j-1`번째 색은 선택하지 못한다.
	- `j`번째 색을 선택하므로 `i-1`개를 더 선택하면 된다.
	- 따라서 1~`j-2`까지 중 `i-1`개를 고르는 경우의 수를 구한다.
	- **dp[i-1][j-2]**
2. j번째 색을 선택하지 않는 경우
	- 1~`j-1`까지 중 `i`개를 고르는 경우의 수를 구한다.
	- **dp[i][j-1]**

위에 해당하는 각 경우를 더하면 `dp[i][j]` 값을 구할 수 있다.

하지만 주의해야 할 점은, 정답으로 출력되어야 할 `dp[N][K]`이다.  
편의상 배열을 사용한 것이고 실제로는 원형으로 배열 양 끝이 이어져있기 때문에  
`N`번째 색상을 선택한 경우 첫번째 색상은 선택할 수 없다.  
따라서 `dp[N][K]`를 구할 때는 `N`번째 색을 선택한 경우,  
2~`N-2`까지 중 `K-1`개를 고르는 경우의 수를 구해야 한다.  
즉, `dp[N][K] = dp[N-3][K-1] + dp[N-1][K]`이다.


![KakaoTalk_20220327_221026885](https://user-images.githubusercontent.com/57346428/160282989-0d994697-a408-48b3-83e8-b19413d6998d.jpg)


# 2. 새로 배운 내용(코드 위주)
