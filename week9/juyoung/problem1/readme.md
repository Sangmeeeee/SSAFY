# Info

문제 : [전깃줄](https://www.acmicpc.net/problem/2565)

알고리즘 종류 : DP

참조 url :


# 1. 알고리즘 설명

**LIS 알고리즘**을 사용했다.  
서로 연결된 전깃줄을 전봇대 A의 위치를 기준으로 정렬했을 때,  
전봇대 B의 위치에서 최장 증가 수열의 길이를 찾고 이를 `N`에서 빼면 답이 나온다.  
여기서의 최장 증가 수열이란 겹치지 않고 연결될 수 있는 전깃줄의 최대 개수이기 때문이다.

 
LIS 알고리즘은 dp 배열을 사용하는데, 이때 dp 배열은
`dp[i]` : **i번 인덱스를 포함하는 최장 증가 수열의 길이** 와 같이 정의된다.


1. 전깃줄 위치를 입력 받으며 `dp` 배열을 1로 초기화한다.
	- 최장 증가 수열에 자신만 포함될 때의 길이가 1이므로!
2. 입력 받은 전깃줄 배열을 전봇대 A의 위치를 기준으로 오름차순 정렬한다.
3. 최장 증가 수열을 찾고 `dp` 배열에 기록한다.
	1. 0번부터 N-1번까지(`i`) 돌면서 `i`와 `i`의 이전 인덱스(`j`) 값들을 비교한다.
	2. `i`번째 전깃줄이 연결된 전봇대 B의 위치가 `j`번째 전깃줄이 연결된 전봇대 B의 위치보다 크다면
		- 최장 증가 수열이므로 `dp[i]`에 `dp[i]`와 `dp[j]+1` 중 더 큰 값을 대입한다.
	3. `answer`와 `dp[i]` 값 중 더 큰 값을 `answer`에 저장한다.
4. 전체 전깃줄의 개수 `N`에서 최장 증가 수열의 길이 `answer`를 뺀 값을 출력한다.

![KakaoTalk_20220321_225255966](https://user-images.githubusercontent.com/57346428/159278029-b698e552-8596-403a-ae72-b52611d1964b.jpg)


# 2. 새로 배운 내용(코드 위주)
