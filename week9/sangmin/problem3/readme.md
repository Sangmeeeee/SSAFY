문제 : [타일 채우기 3](https://www.acmicpc.net/problem/14852)

알고리즘 종류 : dp

참조 url : https://j3sung.tistory.com/726

# 1. 알고리즘 설명

처음에는 dp[i] = i번째 타일까지 왔을때 타일을 채우는 경우의 수 = (dp[i - 1] * 2 + dp[i - 2] * 3) 으로 생각해서 틀렸다.

사실 위의 점화식은 특수한 상황 한가지를 제외하고는 맞는 점화식이다.

해당 점화식으로 3번째 타일까지 구할경우 20가지의 경우의 수가 나온다.

하지만 3일경우 정답은 22인데, 놓친 2가지 경우의 수가 있다.

해당 점화식을 해석해보면 dp[3] = dp[2]의 경우의 수 * (1*1의 타일 2개를 쓸 경우 + 2*1의 타일 1개를 쓸 경우) + dp[1] * (1 * 2의 타일 2개를 쓸 경우, 1 * 2의 타일 1개와 1 * 1의 타일 2개를 쓸경우 * 2)를 해준 결과다.

하지만 2 * 3의 타일을 나누는 경우의 수를 보면 

    * - -  - - *
    - - *  * - -

와 같이 dp[i - 1]이나 dp[i - 2]에서 시작할 수 없는 특수한 경우들이 생긴다.

따라서 dp[3]일경우 20 + 특수한 경우 2 = 22가 된다.

위와같은 특수한 경우 또한 dp로 나타내기 위해 dp 배열을 2차원 배열으로 나누고 dp[0][i] = i번째 타일까지 정상적으로 타일을 채우는 경우의 수,

dp[1][i] = i번째 타일까지 dp[0][j]에서 뽑아낼 수 없는(특수하게 생긴) 타일을 채우는 경우의 수로 정의한다.

dp[i][i]번째 조건은 어렵게 생각하지 않고 i번째 타일의 위가 비어있고 아래 타일이 무조건 1 * 2인(ㄴ 모양의 타일)경우의 수라고 생각한다.

위 아래가 다를수도 있지만 해당 부분은 dp[0][1]을 구할 때 * 2를 해주면 된다.(위 아래가 대칭이기 때문)

그렇다면 특수한 경우까지 포함해서 dp[0][i] = dp[1][i] * 2 + dp[0][i - 1] * 2 + dp[0][i - 2] * 3으로 구할 수 있다.

![image](https://user-images.githubusercontent.com/24482602/159722161-67f9edc0-c2e5-4201-a304-4f92aba9b793.png)

특수한 경우를 담은 dp[1][i]를 구하기 위해선? dp[1][i]의 포인트만 생각한다.

dp[1][i]의 정의는 i번째 타일의 위가 비어있고 아래 타일이 무조건 1 * 2가 되어야한다.

위와같은 특수한 경우를 만들기 위해선 dp[1][i] = dp[1][i - 1]이 된다.

그도 그럴게 dp[1][i-1]을 위 아래로 뒤집고 1 * 2 타일만 아래에 더해주면 손쉽게 dp[1][i]를 구할 수 있다.

여기서 끝이 아니다. dp[0][j]에서 특수한 경우로 오는 경우도 생각해봐야한다.

정상적인 경우에서 특수한 경우가 만들어지기 위해선 무조건 3칸을 더해줘야한다.

    - -
    * - -

아래가 1 * 2고 위가 *인 상황은 아래 타일이 1 * 2이지만 특수한 상황이 아니다.

    *
    - -

위와같은 상황은

    * *
    - -

으로 바뀌는데 이는 

dp[i - 2] * 3의 경우의 수에 포함되기 정상적인 경우이다.

따라서 dp[1][i] = dp[0][i - 3]도 포함되고

dp[1][i] = dp[1][i - 1] + dp[0][i - 3]으로 정의할 수 있다.

![image](https://user-images.githubusercontent.com/24482602/159722354-312d0033-13d7-4d23-ba07-66a817ba035b.png)

# 2. 새로 배운 내용