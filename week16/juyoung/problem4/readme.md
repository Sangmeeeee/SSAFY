# Info

문제 : [튜플](https://programmers.co.kr/learn/courses/30/lessons/64065)

알고리즘 종류 : 

참조 url : [다른 사람의 풀이에 '-'님 코드](https://programmers.co.kr/learn/courses/30/lessons/64065/solution_groups?language=cpp)


# 1. 알고리즘 설명

### :star: problem4.cpp

내가 직접 푼.. 아주 못난 풀이.. ^_ㅜ  

:round_pushpin: 전체 풀이  
첫째, **입력 문자열에서 각 집합을 2차원 벡터에 삽입한다.**

현재 문자가 숫자이면 숫자를 1차원 벡터에 삽입한다.  
그렇지 않다면 몇가지 처리가 필요한데 이때, 집합의 구분을 위해 스택을 사용했다.  
현재 문자가 '{'라면 스택에 push하고, '}'라면 스택을 pop한다.  
그러다가 현재 문자가 ','이면 스택이 비어있는 경우와 비어있지 않은 경우로 나뉜다.

만약 스택이 비어있다면 어느 한 집합이 끝났음을 의미하기 때문에  
현재까지 숫자를 삽입한 1차원 벡터를 2차원 벡터에 삽입한 후 1차원 벡터를 초기화한다.  
만약 스택이 비어있지 않다면, 아직 집합 안이라는 의미이므로 따로 처리할 필요가 없다.

둘째, 2차원 벡터에 집합 별로 벡터가 삽입된 후, **2차원 벡터를 정렬한다.**  
이때 `cmp`라는 사용자 정의 함수를 통해 길이 순으로 오름차순 정렬하도록 했다.

셋째, **정렬된 2차원 벡터를 순회하며 정답 벡터에 숫자를 삽입한다.**  

정렬된 벡터 안에는 차례대로 원소의 개수가 1개, 2개, 3개, 4개인 벡터가 있다.  
집합 안에서 수의 순서가 바뀐 경우가 있기 때문에 map을 이용하여 중복된 값이 들어가지 않도록 했다.  
map 내에 존재하지 않는 수이면 정답 배열에 삽입한 후 map에 추가했고,  
map 내에 존재하는 수이면 아무 처리 없이 넘어간다.

:round_pushpin:  
빠르게 푸는 데에 집중해서 풀었더니 이런 풀이가 나왔다...  
테스트케이스 10번대에서 실행시간이 거의 3000ms가 나오길래 망했다고 생각했다.  

풀고나서도 쓸데없는 자료구조를 많이 쓰고 코드가 더럽다고 느꼈는데  
다른 사람 코드를 보니까 확실해졌다...ㅠㅠ  
그래서 다른 코드를 참고해서 다시 한번 짜본 게 `problem4_2.cpp`이다.


### :star: problem4_2.cpp

:round_pushpin:  
**정수형 `flag` 배열을 사용하여 튜플의 구성 요소를 표시한다.**  
만약 `flag[10] = 3`이라면 4개의 집합 중 3개의 집합에 10이 들어있다는 의미이다.  
튜플의 첫번째 원소는 집합에 4번, 두번째 원소는 3번, 세번째 원소는 2번, 네번째 원소는 1번 등장한다는 점을 이용하는 것이다.    

입력 문자열을 탐색할 때, 숫자이거나 아닌 경우만을 고려한다.  
1. `s[i]`가 숫자라면
	- 문자열 `number`에 더한다.
2. `s[i]`가 숫자가 아니라면, 그리고 `number`에 문자열이 저장되어 있다면
	- `flag[stoi(number)]`를 1만큼 증가시키고 `number`를 초기화한다.

그리고 두 정수를 저장하는 pair형 벡터 `numbers`를 사용하는데,  
여기에 튜플의 구성 요소와 집합에 등장한 횟수(`flag`에 저장된 값)을 삽입한다.
그리고 `numbers` 벡터를 구성 요소가 집합에 등장한 횟수를 기준으로 정렬한다.

그리고 정렬한 값을 차례대로 정답 배열 `answer`에 삽입하면 된다.

:round_pushpin:  
확실히 내가 푼 풀이랑 테케 실행시간 차이가 엄청 났다...  
문자열에서 필요한 부분만 고려하고, 자료구조도 단순히 배열을 쓰면 되는 거였는데  
너무 어렵게 생각하고 푼 것 같다...


# 2. 새로 배운 내용(코드 위주)
[참고](https://learncom1234.tistory.com/6)

### 2차원 벡터에서 1차원 벡터의 길이 기준으로 정렬하기
```cpp
bool cmp(vector<int> a, vector<int> b) {
	return a.size() < b.size();
}
sort(v.begin(), v.end(), cmp);
```