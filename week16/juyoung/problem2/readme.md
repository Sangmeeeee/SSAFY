# Info

문제 : [거리두기 확인하기](https://programmers.co.kr/learn/courses/30/lessons/81302)

알고리즘 종류 : 

참조 url : 


# 1. 알고리즘 설명
 
31번 테스트케이스를 통과 못 했다...  
지쳐서 일단 30번까지 통과한 코드와 풀이 방법을 올린다...

:round_pushpin:  
**bfs**를 이용해서 풀었다.  
**맨해튼의 거리가 2 이내인 부분**이 한 위치를 중심으로 **bfs를 2번 수행한 부분과 같기 때문**이다.  
(그림 참고)

![KakaoTalk_20220511_021232140](https://user-images.githubusercontent.com/57346428/167688202-c54ee699-4062-4202-8171-f9f4a499b3e6.jpg)

:round_pushpin:  
**풀이 방법**은 다음과 같다.    
1. 응시자가 앉아있는 자리의 위치들을 벡터에 저장한다.
2. 벡터에 저장한 자리를 하나씩 꺼내서 각각 bfs를 2번씩 돌린다.
	- bfs를 돌릴 때, 방문한 위치가 'X'라면 큐에 넣지 않고, 'P'라면 0을 반환한다.
	- bfs를 두 번 돌리고 난 이후 1을 반환한다.
3. bfs 함수가 반환하는 결과에 따라 `answer`에 0이나 1을 삽입한다.

:round_pushpin:  
**헷갈릴 수 있었던 부분.**

입력이 주어진 걸 보면 `places`는 대기실 5개를 저장하고 있음을 알 수 있다.  
따라서 bfs 수행 시 실질적으로 탐색해야하는 부분은 `places[i]`에 속하는 대기실이며,  
이에 대한 참조는 `places[i][y][x]` 형식으로 해야 한다.  
그래서 나는 bfs 함수의 인자로 현재 `i`를 `idx`로 넘겨줘서 `places[idx][ny][nx]` 형식으로 접근하도록 했다.


# 2. 새로 배운 내용(코드 위주)
