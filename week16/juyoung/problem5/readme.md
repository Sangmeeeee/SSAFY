# Info

문제 : [순위 검색](https://programmers.co.kr/learn/courses/30/lessons/72412)

알고리즘 종류 :

참조 url : https://algosu.tistory.com/99


# 1. 알고리즘 설명

주어진 `info`에 담긴 정보에 대해 모든 경우의 수를 미리 만들고 시작해야겠다는 생각은 했는데  
어떻게 구현할지 잘 모르겠어서 다른 분 코드를 참고해서 풀었다.

:star: **풀이 흐름**  
map을 사용하여 푸는데, key는 문자열로 된 조건이며 value는 그 조건을 만족하는 사람들의 점수 벡터이다.  
1. `info`에서 주어진 각 정보에 대해 "-"를 포함한 모든 경우의 key를 구하고, map에 점수와 함께 담는다.
2. map의 벡터들을 정렬한다.
3. `query`의 각 문자열을 key 형태로 변환하고 map에서 해당하는 사람의 수를 구한다.

:star: **상세 설명**  
**<< 1. >>**
우선, 주어진 지원자들의 정보로 key를 만들어야 한다.  
key의 형태는 지원자의 점수를 제외한 모든 정보를 공백 없이 붙인 것이다.  
예를 들어, 지원자의 정보가 "java backend junior pizza 150"이라면  
key는 "javabackendjuniorpizza"가 되는 것이다.  
공백을 구분하여 입력받기 위해 `<sstream>` 헤더 파일의 `stringstream` 변수를 사용했다.  

그런데 문제에서는 어느 조건을 제외하는 "-"가 존재한다.  
따라서 각 조건이 지원자의 정보이거나 "-"인 모든 경우에 대해 key를 만들어 map에 삽입해야 한다.  
이때 `detail`이라는 2차원 배열을 선언하여 0번째 열엔 "-"를, 1번째 열엔 지원자의 정보를 넣었다.  
그리고 이 배열을 이용하여 4중 for문으로 모든 경우의 수를 구했다.  
그 과정을 그림으로 나타내봤다. (:arrow_down:)

`table`은 map이며, key는 string 타입이고 value는 vector<int> 타입이다.  
![KakaoTalk_20220513_171809827](https://user-images.githubusercontent.com/57346428/168244234-3f4fbfa7-4d8c-430e-ba7c-7cdd90282c42.jpg)

모든 지원자에 대한 위 과정이 끝나면 map에 최대 108가지의 원소가 삽입된다.  
`{"java", "python", "cpp", "-"}` 4가지, `{"frontend", "backend", "-"}` 3가지,  
`{"junior", "senior", "-"}` 3가지, `{"chicken", "pizza", "-"}` 3가지로 4*3*3*3 = 108가지이다.

**<< 2. >>**  
map에 들어있는 벡터들을 오름차순 정렬해준다.  
정렬해주는 이유는 3번 과정에서 `lower_bound()`를 사용하기 위해서이다.  
`lower_bound()` 함수를 사용할 때, 그 배열은 오름차순으로 정렬되어 있어야 하기 때문이다.

**<< 3. >>**  
각 `query`를 key로 변환하고, map의 해당 원소에서 점수 조건을 만족하는 사람의 수를 구해야한다.  
1번 과정에서 만든 key와 같은 형태로 `query`에서 조건을 뽑아 key를 만든다.  
그리고 map에서 해당하는 key에 접근하여 넘어야하는 점수에 대해 `lower_bound()`를 수행하여 답을 구한다.  

처음에는 `table[key]`의 벡터에서 점수를 넘는 경우에 `cnt`를 증가시키도록 했는데, 효율성 검사에서 실패했다.  
그래서 `lower_bound()` 함수를 썼더니 효율성 검사를 통과했다.  
for문으로 벡터 전체를 돌면서 if문으로 거르는 건 시간복잡도가 `O(N)`이고,  
`lower_bound()` 함수는 이분 탐색을 사용하기 때문에 시간복잡도가 `O(logN)`이 걸려서 그런 것 같다.


# 2. 새로 배운 내용(코드 위주)
